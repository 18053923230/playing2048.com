# å›¾ç‰‡èµ„æºä¸åŠ¨æ€ç”Ÿæˆ 2048 æ¸¸æˆæ–¹æ¡ˆ

## ğŸ¯ æ ¸å¿ƒéœ€æ±‚åˆ†æ

ç”¨æˆ·éœ€æ±‚ï¼š

- é€‰æ‹©ä»»æ„å›¾ç‰‡ä¸»é¢˜ï¼ˆå­™æ‚Ÿç©ºã€æ±½è½¦ã€åŠ¨ç‰©ç­‰ï¼‰
- è‡ªåŠ¨ç”Ÿæˆå¯¹åº”çš„ 2048 æ¸¸æˆï¼ˆsunwukong 2048ã€car 2048 ç­‰ï¼‰
- å®ç°çœŸæ­£çš„è‡ªå®šä¹‰åŒ–

## ğŸ–¼ï¸ å›¾ç‰‡èµ„æºè·å–ç­–ç•¥

### æ–¹æ¡ˆ 1ï¼šAI ç”Ÿæˆå›¾ç‰‡ï¼ˆæ¨èï¼‰

#### ä½¿ç”¨ Stable Diffusion API

```typescript
// lib/imageGeneration/stableDiffusion.ts
interface ImageGenerationRequest {
  prompt: string;
  style: string;
  count: number;
  size: "256x256" | "512x512" | "1024x1024";
}

export class ImageGenerator {
  private apiKey: string;
  private baseUrl = "https://api.stability.ai/v1/generation";

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async generateThemeImages(
    theme: string,
    count: number = 12
  ): Promise<string[]> {
    const prompts = this.generatePrompts(theme, count);
    const images: string[] = [];

    for (const prompt of prompts) {
      try {
        const response = await fetch(
          `${this.baseUrl}/stable-diffusion-xl-1024-v1-0/text-to-image`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${this.apiKey}`,
            },
            body: JSON.stringify({
              text_prompts: [
                {
                  text: prompt,
                  weight: 1,
                },
              ],
              cfg_scale: 7,
              height: 512,
              width: 512,
              samples: 1,
              steps: 30,
            }),
          }
        );

        const result = await response.json();
        if (result.artifacts && result.artifacts[0]) {
          const imageData = result.artifacts[0].base64;
          images.push(`data:image/png;base64,${imageData}`);
        }
      } catch (error) {
        console.error("Image generation failed:", error);
      }
    }

    return images;
  }

  private generatePrompts(theme: string, count: number): string[] {
    const basePrompts = [
      `${theme}, simple icon, flat design, white background, 2D style`,
      `${theme}, cute cartoon, simple design, white background`,
      `${theme}, minimalist icon, clean design, white background`,
      `${theme}, pixel art style, simple, white background`,
      `${theme}, geometric design, simple shapes, white background`,
      `${theme}, modern icon, flat design, white background`,
      `${theme}, retro style, simple design, white background`,
      `${theme}, vector art, clean design, white background`,
      `${theme}, abstract representation, simple design, white background`,
      `${theme}, stylized icon, flat design, white background`,
      `${theme}, modern minimalist, simple design, white background`,
      `${theme}, clean icon design, white background`,
    ];

    return basePrompts.slice(0, count);
  }
}
```

#### ä½¿ç”¨ OpenAI DALL-E API

```typescript
// lib/imageGeneration/dalle.ts
export class DalleGenerator {
  private apiKey: string;

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async generateThemeImages(
    theme: string,
    count: number = 12
  ): Promise<string[]> {
    const images: string[] = [];

    for (let i = 0; i < count; i++) {
      const prompt = this.generatePrompt(theme, i);

      try {
        const response = await fetch(
          "https://api.openai.com/v1/images/generations",
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${this.apiKey}`,
            },
            body: JSON.stringify({
              prompt: prompt,
              n: 1,
              size: "512x512",
              response_format: "b64_json",
            }),
          }
        );

        const result = await response.json();
        if (result.data && result.data[0]) {
          const imageData = result.data[0].b64_json;
          images.push(`data:image/png;base64,${imageData}`);
        }
      } catch (error) {
        console.error("DALL-E generation failed:", error);
      }
    }

    return images;
  }

  private generatePrompt(theme: string, index: number): string {
    const styles = [
      "simple icon design",
      "cute cartoon style",
      "minimalist flat design",
      "pixel art style",
      "geometric design",
      "modern icon",
      "retro style",
      "vector art",
      "abstract representation",
      "stylized icon",
      "modern minimalist",
      "clean icon design",
    ];

    return `${theme}, ${styles[index]}, white background, simple design, suitable for 2048 game tile`;
  }
}
```

### æ–¹æ¡ˆ 2ï¼šé¢„è®¾å›¾ç‰‡åº“ + ç”¨æˆ·ä¸Šä¼ 

#### é¢„è®¾ä¸»é¢˜å›¾ç‰‡åº“

```typescript
// lib/imageLibrary/presetThemes.ts
export interface PresetTheme {
  id: string;
  name: string;
  category: string;
  images: string[];
  description: string;
}

export const presetThemes: PresetTheme[] = [
  {
    id: "cupcakes",
    name: "Cupcakes",
    category: "food",
    images: [
      "/images/themes/cupcakes/vanilla.png",
      "/images/themes/cupcakes/chocolate.png",
      "/images/themes/cupcakes/strawberry.png",
      // ... æ›´å¤šå›¾ç‰‡
    ],
    description: "Delicious cupcake themed 2048 game",
  },
  {
    id: "animals",
    name: "Animals",
    category: "nature",
    images: [
      "/images/themes/animals/cat.png",
      "/images/themes/animals/dog.png",
      "/images/themes/animals/elephant.png",
      // ... æ›´å¤šå›¾ç‰‡
    ],
    description: "Cute animal themed 2048 game",
  },
  {
    id: "cars",
    name: "Cars",
    category: "vehicles",
    images: [
      "/images/themes/cars/sedan.png",
      "/images/themes/cars/suv.png",
      "/images/themes/cars/sports.png",
      // ... æ›´å¤šå›¾ç‰‡
    ],
    description: "Exciting car themed 2048 game",
  },
];
```

#### ç”¨æˆ·ä¸Šä¼ å›¾ç‰‡å¤„ç†

```typescript
// lib/imageProcessing/userUpload.ts
export class ImageProcessor {
  async processUserImages(files: File[]): Promise<string[]> {
    const processedImages: string[] = [];

    for (const file of files) {
      try {
        const processedImage = await this.processImage(file);
        processedImages.push(processedImage);
      } catch (error) {
        console.error("Image processing failed:", error);
      }
    }

    return processedImages;
  }

  private async processImage(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      const img = new Image();

      img.onload = () => {
        // è®¾ç½®ç”»å¸ƒå¤§å°ä¸º512x512
        canvas.width = 512;
        canvas.height = 512;

        // è®¡ç®—ç¼©æ”¾å’Œå±…ä¸­
        const scale = Math.min(512 / img.width, 512 / img.height);
        const x = (512 - img.width * scale) / 2;
        const y = (512 - img.height * scale) / 2;

        // ç»˜åˆ¶ç™½è‰²èƒŒæ™¯
        ctx!.fillStyle = "#ffffff";
        ctx!.fillRect(0, 0, 512, 512);

        // ç»˜åˆ¶å›¾ç‰‡
        ctx!.drawImage(img, x, y, img.width * scale, img.height * scale);

        // è½¬æ¢ä¸ºbase64
        const dataUrl = canvas.toDataURL("image/png");
        resolve(dataUrl);
      };

      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }
}
```

## ğŸ® åŠ¨æ€æ¸¸æˆç”Ÿæˆç³»ç»Ÿ

### 1. æ¸¸æˆä¸»é¢˜ç®¡ç†å™¨

```typescript
// lib/game/themeManager.ts
export interface GameTheme {
  id: string;
  name: string;
  images: string[];
  colors: {
    background: string;
    tile: string;
    text: string;
    accent: string;
  };
  labels: string[];
  description: string;
  createdAt: Date;
  isCustom: boolean;
}

export class ThemeManager {
  private themes: Map<string, GameTheme> = new Map();

  async createCustomTheme(
    name: string,
    images: string[],
    colors?: Partial<GameTheme["colors"]>
  ): Promise<GameTheme> {
    const themeId = this.generateThemeId(name);

    const theme: GameTheme = {
      id: themeId,
      name,
      images,
      colors: {
        background: colors?.background || "#fdf6e3",
        tile: colors?.tile || "#f0e68c",
        text: colors?.text || "#2f4f4f",
        accent: colors?.accent || "#ff69b4",
      },
      labels: this.generateLabels(name, images.length),
      description: `${name} themed 2048 game`,
      createdAt: new Date(),
      isCustom: true,
    };

    this.themes.set(themeId, theme);
    await this.saveTheme(theme);

    return theme;
  }

  private generateThemeId(name: string): string {
    return name.toLowerCase().replace(/[^a-z0-9]/g, "-");
  }

  private generateLabels(name: string, count: number): string[] {
    const labels = [];
    for (let i = 0; i < count; i++) {
      labels.push(`${name} ${i + 1}`);
    }
    return labels;
  }

  private async saveTheme(theme: GameTheme): Promise<void> {
    // ä¿å­˜åˆ°localStorageæˆ–æ•°æ®åº“
    const themes = JSON.parse(localStorage.getItem("custom-themes") || "{}");
    themes[theme.id] = theme;
    localStorage.setItem("custom-themes", JSON.stringify(themes));
  }

  async loadTheme(themeId: string): Promise<GameTheme | null> {
    // å…ˆæ£€æŸ¥å†…å­˜ä¸­çš„ä¸»é¢˜
    if (this.themes.has(themeId)) {
      return this.themes.get(themeId)!;
    }

    // ä»localStorageåŠ è½½
    const themes = JSON.parse(localStorage.getItem("custom-themes") || "{}");
    const theme = themes[themeId];

    if (theme) {
      this.themes.set(themeId, theme);
      return theme;
    }

    return null;
  }
}
```

### 2. åŠ¨æ€æ¸¸æˆç”Ÿæˆå™¨

```typescript
// lib/game/dynamicGameGenerator.ts
export class DynamicGameGenerator {
  private themeManager: ThemeManager;
  private imageGenerator: ImageGenerator;

  constructor() {
    this.themeManager = new ThemeManager();
    this.imageGenerator = new ImageGenerator(process.env.STABILITY_API_KEY!);
  }

  async generateGameFromTheme(themeName: string): Promise<GameTheme> {
    // 1. ç”Ÿæˆå›¾ç‰‡
    const images = await this.imageGenerator.generateThemeImages(themeName, 12);

    // 2. åˆ›å»ºä¸»é¢˜
    const theme = await this.themeManager.createCustomTheme(themeName, images);

    // 3. ç”Ÿæˆæ¸¸æˆé¡µé¢
    await this.generateGamePage(theme);

    return theme;
  }

  async generateGameFromImages(
    themeName: string,
    images: string[]
  ): Promise<GameTheme> {
    // 1. åˆ›å»ºä¸»é¢˜
    const theme = await this.themeManager.createCustomTheme(themeName, images);

    // 2. ç”Ÿæˆæ¸¸æˆé¡µé¢
    await this.generateGamePage(theme);

    return theme;
  }

  private async generateGamePage(theme: GameTheme): Promise<void> {
    // ç”ŸæˆåŠ¨æ€è·¯ç”±é¡µé¢
    const pageContent = this.generatePageContent(theme);

    // è¿™é‡Œå¯ä»¥åŠ¨æ€åˆ›å»ºNext.jsé¡µé¢æ–‡ä»¶
    // æˆ–è€…ä½¿ç”¨åŠ¨æ€è·¯ç”±
  }

  private generatePageContent(theme: GameTheme): string {
    return `
import { SEOHead } from '@/components/seo/SEOHead';
import { DynamicGameBoard } from '@/components/game/DynamicGameBoard';
import { theme } from '@/lib/game/themes/${theme.id}';

export default function ${theme.name}Page() {
  return (
    <>
      <SEOHead 
        title="${theme.name} 2048 - Play Online Free"
        description="Play ${theme.name} 2048 online for free! Custom themed puzzle game."
        keywords="${theme.name} 2048, ${theme.name} puzzle game, custom 2048"
      />
      <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
        <div className="container mx-auto px-4 py-8">
          <h1 className="text-4xl font-bold text-center mb-8">${theme.name} 2048</h1>
          <DynamicGameBoard theme={theme} />
        </div>
      </div>
    </>
  );
}
    `;
  }
}
```

### 3. åŠ¨æ€æ¸¸æˆç»„ä»¶

```typescript
// components/game/DynamicGameBoard.tsx
"use client";

import React, { useState, useEffect } from "react";
import { GameTheme } from "@/lib/game/themeManager";
import { Game2048 } from "@/lib/game/gameLogic";

interface DynamicGameBoardProps {
  theme: GameTheme;
}

export const DynamicGameBoard: React.FC<DynamicGameBoardProps> = ({
  theme,
}) => {
  const [game, setGame] = useState<Game2048 | null>(null);
  const [gameState, setGameState] = useState<any>(null);

  useEffect(() => {
    const newGame = new Game2048({
      size: 4,
      targetValue: 4096,
      theme: theme.id,
      difficulty: "medium",
    });

    newGame.loadGame();
    setGame(newGame);
    setGameState(newGame.getState());
  }, [theme]);

  const handleMove = (direction: string) => {
    if (!game) return;

    const moved = game.move(direction as any);
    if (moved) {
      setGameState(game.getState());
    }
  };

  if (!gameState) {
    return <div>Loading...</div>;
  }

  return (
    <div className="max-w-4xl mx-auto">
      <div className="grid md:grid-cols-3 gap-8">
        {/* æ¸¸æˆç»Ÿè®¡ */}
        <div className="md:col-span-1">
          <div className="bg-white rounded-lg shadow-lg p-6">
            <h2 className="text-2xl font-bold mb-4">Score</h2>
            <div className="text-3xl font-bold text-blue-600">
              {gameState.score}
            </div>
            <div className="text-sm text-gray-500">
              Best: {gameState.bestScore}
            </div>
          </div>
        </div>

        {/* æ¸¸æˆæ£‹ç›˜ */}
        <div className="md:col-span-2 flex justify-center">
          <div className="bg-white rounded-lg shadow-lg p-4">
            <div className="grid grid-cols-4 gap-2 w-80 h-80 bg-gray-300 rounded-lg p-2">
              {gameState.board.map((row: any[], rowIndex: number) =>
                row.map((tile: any, colIndex: number) => (
                  <div
                    key={`${rowIndex}-${colIndex}`}
                    className="w-full h-full bg-gray-100 rounded-lg flex items-center justify-center"
                  >
                    {tile && (
                      <div
                        className="w-full h-full rounded-lg flex items-center justify-center"
                        style={{
                          backgroundColor: theme.colors.tile,
                          color: theme.colors.text,
                        }}
                      >
                        <img
                          src={theme.images[tile.value - 1] || theme.images[0]}
                          alt={theme.labels[tile.value - 1] || theme.name}
                          className="w-12 h-12 object-contain"
                        />
                      </div>
                    )}
                  </div>
                ))
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};
```

## ğŸ¨ ç”¨æˆ·ç•Œé¢è®¾è®¡

### 1. ä¸»é¢˜é€‰æ‹©é¡µé¢

```typescript
// app/create/page.tsx
"use client";

import { useState } from "react";
import { SEOHead } from "@/components/seo/SEOHead";
import { ThemeSelector } from "@/components/theme/ThemeSelector";
import { ImageUploader } from "@/components/theme/ImageUploader";
import { DynamicGameGenerator } from "@/lib/game/dynamicGameGenerator";

export default function CreatePage() {
  const [selectedTheme, setSelectedTheme] = useState<string>("");
  const [customImages, setCustomImages] = useState<File[]>([]);
  const [isGenerating, setIsGenerating] = useState(false);

  const handleThemeGeneration = async () => {
    setIsGenerating(true);

    try {
      const generator = new DynamicGameGenerator();
      let theme;

      if (customImages.length > 0) {
        // ä½¿ç”¨ç”¨æˆ·ä¸Šä¼ çš„å›¾ç‰‡
        const imageProcessor = new ImageProcessor();
        const processedImages = await imageProcessor.processUserImages(
          customImages
        );
        theme = await generator.generateGameFromImages(
          selectedTheme,
          processedImages
        );
      } else {
        // ä½¿ç”¨AIç”Ÿæˆå›¾ç‰‡
        theme = await generator.generateGameFromTheme(selectedTheme);
      }

      // è·³è½¬åˆ°ç”Ÿæˆçš„æ¸¸æˆé¡µé¢
      window.location.href = `/${theme.id}`;
    } catch (error) {
      console.error("Theme generation failed:", error);
    } finally {
      setIsGenerating(false);
    }
  };

  return (
    <>
      <SEOHead
        title="Create Custom 2048 Game - Playing2048.com"
        description="Create your own custom 2048 game with any theme you want!"
        keywords="custom 2048, create 2048 game, personalized 2048"
      />

      <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100">
        <div className="container mx-auto px-4 py-8">
          <h1 className="text-4xl font-bold text-center mb-8">
            Create Your Custom 2048 Game
          </h1>

          <div className="max-w-4xl mx-auto">
            <div className="bg-white rounded-lg shadow-lg p-8">
              <h2 className="text-2xl font-bold mb-6">Choose Your Theme</h2>

              {/* é¢„è®¾ä¸»é¢˜é€‰æ‹© */}
              <ThemeSelector onSelect={setSelectedTheme} />

              {/* è‡ªå®šä¹‰å›¾ç‰‡ä¸Šä¼  */}
              <div className="mt-8">
                <h3 className="text-xl font-bold mb-4">
                  Or Upload Your Own Images
                </h3>
                <ImageUploader onImagesSelected={setCustomImages} />
              </div>

              {/* ç”ŸæˆæŒ‰é’® */}
              <div className="mt-8 text-center">
                <button
                  onClick={handleThemeGeneration}
                  disabled={
                    (!selectedTheme && customImages.length === 0) ||
                    isGenerating
                  }
                  className="bg-blue-500 text-white px-8 py-3 rounded-lg hover:bg-blue-600 disabled:opacity-50"
                >
                  {isGenerating ? "Generating..." : "Generate My 2048 Game"}
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  );
}
```

### 2. ä¸»é¢˜é€‰æ‹©å™¨ç»„ä»¶

```typescript
// components/theme/ThemeSelector.tsx
"use client";

import { useState } from "react";
import { presetThemes } from "@/lib/imageLibrary/presetThemes";

interface ThemeSelectorProps {
  onSelect: (theme: string) => void;
}

export const ThemeSelector: React.FC<ThemeSelectorProps> = ({ onSelect }) => {
  const [searchTerm, setSearchTerm] = useState("");

  const filteredThemes = presetThemes.filter(
    (theme) =>
      theme.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      theme.category.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <div>
      <input
        type="text"
        placeholder="Search themes..."
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        className="w-full p-3 border border-gray-300 rounded-lg mb-4"
      />

      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
        {filteredThemes.map((theme) => (
          <div
            key={theme.id}
            onClick={() => onSelect(theme.name)}
            className="bg-gray-50 rounded-lg p-4 cursor-pointer hover:bg-gray-100 transition-colors"
          >
            <img
              src={theme.images[0]}
              alt={theme.name}
              className="w-16 h-16 mx-auto mb-2 object-contain"
            />
            <h3 className="text-center font-bold">{theme.name}</h3>
            <p className="text-center text-sm text-gray-500">
              {theme.category}
            </p>
          </div>
        ))}
      </div>
    </div>
  );
};
```

## ğŸš€ å®æ–½æ­¥éª¤

### ç¬¬ 1 æ­¥ï¼šè®¾ç½®å›¾ç‰‡ç”Ÿæˆ API

1. æ³¨å†Œ Stability AI æˆ– OpenAI API
2. é…ç½® API å¯†é’¥
3. æµ‹è¯•å›¾ç‰‡ç”ŸæˆåŠŸèƒ½

### ç¬¬ 2 æ­¥ï¼šå®ç°åŠ¨æ€è·¯ç”±

1. åˆ›å»º`[themeId]/page.tsx`åŠ¨æ€è·¯ç”±
2. å®ç°ä¸»é¢˜åŠ è½½é€»è¾‘
3. æµ‹è¯•åŠ¨æ€é¡µé¢ç”Ÿæˆ

### ç¬¬ 3 æ­¥ï¼šç”¨æˆ·ç•Œé¢å¼€å‘

1. åˆ›å»ºä¸»é¢˜é€‰æ‹©é¡µé¢
2. å®ç°å›¾ç‰‡ä¸Šä¼ åŠŸèƒ½
3. æ·»åŠ æ¸¸æˆç”Ÿæˆæµç¨‹

### ç¬¬ 4 æ­¥ï¼šä¼˜åŒ–å’Œæµ‹è¯•

1. å›¾ç‰‡ç”Ÿæˆè´¨é‡ä¼˜åŒ–
2. æ¸¸æˆæ€§èƒ½ä¼˜åŒ–
3. ç”¨æˆ·ä½“éªŒæµ‹è¯•

è¿™ä¸ªæ–¹æ¡ˆå¯ä»¥è®©ä½ å®ç°çœŸæ­£çš„è‡ªå®šä¹‰åŒ– 2048 æ¸¸æˆï¼Œç”¨æˆ·å¯ä»¥é€‰æ‹©ä»»ä½•ä¸»é¢˜ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨ç”Ÿæˆå¯¹åº”çš„æ¸¸æˆï¼
